<?php

/**
 * @file
 * Module file for my Loopedia Module
 */



/**
 * Implements hook_node_info().
 *
 * We use hook_node_info() to define the loopedia node content type.
 */
function loopedia_node_info()
{
  return array(
    'lop_integral' => array(
      'name' => t('Integral'),
      // 'base' should be the (machine) name of the module. If it is
      // not, this content type will not appear in structure -> content
      // type.
      'base' => 'loopedia',
      'description' => t('This is the node type for Feynman Integrals'),
      'has_title' => '1',
      'title_label' => t('Integral Title'),
      // 'help' => t('This is an explanation that should help you.')
    ),
  );
}


/**
 * Implements hook_form().
 *
 * This is the form that the user sees when he wants to upload an integral.
 *
 */
function loopedia_form($node, $form_state) {
  // node_content_form() is the standard function that returns a form. It is
  // provided by the "node" module.
  return node_content_form($node, $form_state);
}


/** Implements hook_form_alter().
 *
 */
function loopedia_form_alter(&$form, &$form_state, $form_id)
{
  // dpm($form_id, '$form_id');
  // dpm($form, '$form');
  // dpm($form_state, '$form_state');
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Here, we want to change the standard submission form to a more custom
 * version.
 */
function loopedia_form_lop_integral_node_form_alter(&$form, &$form_state, $form_id)
{
  // // Add an extra validate function
  // $form['#validate'][] = $form['#validate'][0];
  // $form['#validate'][0] = 'loopedia_lop_integral_form_validate';

  // Here we try to auto-check the checkbox that triggers a revision
  // control
  $form['revision_information']['revision']['#default_value'] = 1;



  // lop_picture_path will never be visible because we store here the
  // path to the generated picture of the integral.
  $form['lop_picture_path']['#pre_render'] = array('loopedia_empty_array');


  // // We want so set a value for a field through our srcipts. But the
  // // user still wants to see the value that we put in. The way to go is
  // // this. Define "#default_value" here in form_alter() and it will be
  // // put into the generated form.
  // $form['lop_light_like_leg_number']['und'][0]['value']['#default_value'] = '123';




  // // If you want to hide a field in a form, this seems like the way to
  // // go. You define an '#attributes' to a field  in the following
  // // manner. This just marks the form invisible in css. If the user
  // // turns css off, he still can see the field. See
  // // http://drupal.stackexchange.com/questions/7199/how-to-hide-and-or-prevent-access-to-fields-in-a-form-such-as-group-audience-f
  // // This way, you can still populate a field with #default_value and it
  // // will even be validated.
  // //
  // // An alternative way could be using '#prefix'
  // // and '#suffix' according to https://www.drupal.org/node/728398
  // $form['lop_leg_number']['#attributes']['class']['hide_me'] = 'element-hidden';
  // $form['lop_leg_number']['und'][0]['value']['#default_value'] = 'b200';


  // We control the steps of the form with $form_state['step']. If it is
  // not set, we must be on the first page. So we set it to 1. If
  // it is set, we obviously don't want to change it here.
  if (!isset($form_state['step']))
  {
    $form_state['step'] = 1;
  }


  // Decide what to do according to the 'step' variable:
  switch ($form_state['step'])
  {
    case 1:
      loopedia_integral_first_step($form, $form_state);
      break;
    case 2:
      loopedia_integral_second_step($form, $form_state);
      break;
    case 3:
      loopedia_integral_third_step($form, $form_state);
      break;
  }



  // // Here, we put the two fields for each propagator into one fieldset.
  // for ($i = 1; $i <= 12; $i++)
  // {
  //   $form['prop_' . $i] = array(
  //     '#type' => 'fieldset',
  //     '#title' => 'Propagator ' . $i,
  //     '#description' => t('This is the description of the fieldset for the Propagator.'),
  //     '#collapsible' => false,
  //     'lop_propagator_' . $i . '_mass' => $form['lop_propagator_' . $i . '_mass'],
  //     'lop_propagator_' . $i . '_power' => $form['lop_propagator_' . $i . '_power'],
  //     // '#weight' => -4,
  //   );
  //   unset($form['lop_propagator_' . $i . '_mass'],
  //         $form['lop_propagator_' . $i . '_power']);
  // }

  dpm($form_state, '$form_state');
  dpm($form, '$form');
}


/**
 * Callback function for the first step of the integral submission form.
 */
function loopedia_integral_first_step(&$form, &$form_state)
{
  // Define array of fields, that shall be shown
  $elements_to_show = array(
    'lop_nickel',
  );

  _loopedia_display_fields($elements_to_show, $form, $form_state);


  $form['actions']['next'] = array(
    '#type' => 'submit',
    '#value' => 'Next >>',
    '#submit' => array('loopedia_integral_next_submit_1'),
    '#validate' => array('loopedia_integral_next_validate_1'),
  );
  $form['actions']['submit']['#attributes']['class']['hide_me'] = 'element-hidden';


  $form['nickel_adjalist'] = array(
    '#type' => 'fieldset',
    '#title' => 'Nickel or Adjacency List?',
    '#description' => t('Choose if you want to provide a Nickel Index or an Adjacency List'),
    '#collapsible' => false,
    );
  $form['nickel_adjalist']['selection'] = array(
    '#type' => 'radios',
    '#options' => array(
      'nickel'   => t('Nickel Index'),
      'adjalist' => t('Adjacency List'),
    ),
  );

  $form['nickel_adjalist']['adjalist'] = array(
    '#type' => 'textfield',
    '#title' => 'Adjacency List',
    '#size' => 80,
    '#maxlength' => 400,
    // '#required' => TRUE,

    // Only show this filed if "adjacency list" was selected.
    '#states' => array(
      'visible' => array(
        ':input[name="selection"]' => array('value' => 'adjalist'),
      ),
    ),
  );

  $form['lop_nickel']['#states'] = array(
    'visible' => array(
      ':input[name="selection"]' => array('value' => 'nickel'),
    ),
  );
  // $form['lop_nickel']['#element_validate'][] = 'loopedia_lop_nickel_validate';
  unset($form['lop_nickel']['#weight']);
  $form['nickel_adjalist']['lop_nickel'] = $form['lop_nickel'];
  unset($form['lop_nickel']);

}


/**
 * Returns an empty array
 *
 * This is used here to hide fields by setting '#pre_render' to this
 * function.
 */
function loopedia_empty_array()
{
  return array();
}


/**
 * Adjusts which fields will be displayed
 *
 * @param &$fields_to_show array
 *   This is an array of strings. Each string is the name of the field
 *   that you want to be displayed.
 */
function _loopedia_display_fields(&$fields_to_show, &$form, &$form_state)
{
  // Store array of fieldnames in $form_state, if it does not exist.
  if (!isset($form_state['all_fields']))
  {
    // The following two numbers are just copies of the definitions in
    // _loopedia_integral_installed_fields() in "loopedia.install" and
    // thus should be the same.
    $max_num_prop = 21;
    $max_num_leg = 20;

    // This array is trivially associative because later we want to
    // erase some elements.
    $fieldnames = array(
      'lop_comment' => 'lop_comment',
      'lop_nickel' => 'lop_nickel',
      'lop_vertex_number' => 'lop_vertex_number',
      'lop_literature_arxiv' => 'lop_literature_arxiv',
      'lop_literature_publication' => 'lop_literature_publication',
      'lop_int_mass_shell_leg_num' => 'lop_int_mass_shell_leg_num',
      'lop_leg_number' => 'lop_leg_number',
      'lop_light_like_leg_number' => 'lop_light_like_leg_number',
      'lop_loop_number' => 'lop_loop_number',
      'lop_mass_scale_number' => 'lop_mass_scale_number',
      'lop_massless_propagator_number' => 'lop_massless_propagator_number',
      'lop_massive_propagator_number' => 'lop_massive_propagator_number',
      'lop_off_shell_leg_number' => 'lop_off_shell_leg_number',
      'lop_propagator_number' => 'lop_propagator_number',
    );
    // Add the external leg virtualities to $fieldnames :
    for ($i = 1; $i <= $max_num_leg; $i++)
    {
      $fieldnames['lop_ext_leg_' . $i . '_virt'] = 'lop_ext_leg_' . $i . '_virt';
    }
    // Add the mass and power fields for the propagators:
    for ($i = 1; $i <= $max_num_prop; $i++)
    {
      $fieldnames['lop_propagator_' . $i . '_mass'] = 'lop_propagator_' . $i . '_mass';
      $fieldnames['lop_propagator_' . $i . '_power'] = 'lop_propagator_' . $i . '_power';
    }
    $form_state['all_fields'] = $fieldnames;
  }

  // Make a working copy of all fieldnames
  $fields_to_hide = $form_state['all_fields'];

  // Delete fieldnames from working copy that we want to display
  foreach ($fields_to_show as $fieldname)
  {
    unset($fields_to_hide[$fieldname]);
  }

  // Make remaining fields invisible:
  foreach ($fields_to_hide as $hide_me)
  {
    // $form[$hide_me]['#attributes']['class']['hide_me'] = 'element-hidden';
    $form[$hide_me]['#pre_render'] = array('loopedia_empty_array');
  }

}




/**
 * Validate handler for loopedia_integral_first_step next button
 *
 * It might become important, in which order the validation functions
 * are executed. Then, you should experiment with it.
 *
 */
function loopedia_integral_next_validate_1(&$form, &$form_state)
{
  // dpm($form_state);
  // dpm($form, '$form from next_validate');
  if ($form_state['values']['selection'] == 'adjalist')
  {
    // Begin of the check of the given adjacency list

    // Check if the given adjacency list string contains forbidden
    // characters. Allowed ones are ",", "-", "[", "]", "0-9", " "
    // See http://www.rexegg.com/regex-php.html
    if (preg_match('/^[,\[\]0-9\s-]*$/', $form_state['values']['adjalist']) !== 1)
    {
      form_set_error('adjalist', t(
      'Your adjacency list seems to contain not allowed characters. The allowed ones are: "[comma]", "-", "[", "]", "0-9", "[whitespace]"'
    ));
    }



    // Calculate the Nickel index from the given Adjacency List
    $exec0 = "python sites/default/scripts/edgelist_to_nickel.py " .
              escapeshellarg($form_state['values']['adjalist']) .
              " 2>&1";
    $generated_nickel = trim(shell_exec($exec0));



    // If the script outputs more than one line (nickel index), then
    // there must have been an error. So if the output $generated_nickel
    // contains a newline character ("\n" == PHP_EOL), an error is
    // displayed.
    // http://stackoverflow.com/questions/9437121/how-to-detect-if-a-string-has-a-new-line-break-in-it
    if (strpos($generated_nickel, PHP_EOL) !== false)
    {
      form_set_error('adjalist', t(
        "There seems to be a problem with your adjacency list."
      ));
    }
    else
    {
      // The adjacency list and generated nickel index seem to be all
      // right. So we can write the nickel index to the appropriate
      // places:
      $form_state['values']['lop_nickel']['und'][0]['value'] = $generated_nickel;
      $form_state['input']['lop_nickel']['und'][0]['value'] = $generated_nickel;
    }

    // End of check of the given adjacency list.
  }
  else
  {
    // Begin of checking of the given nickel index.
    $nickel_value_given = $form_state['values']['lop_nickel']['und'][0]['value'];

    // Check the formal structure of the given index: it shall only
    // contain "e", "0-9" and "|".
    if (preg_match('/^[e0-9A-Z\|]*$/', $nickel_value_given) !== 1)
    {
      form_set_error('lop_nickel', t('Your Nickel Index seems to contain other characters than the allowed: "e", "0-9", "A-Z", "|".'));
    }


    // Check, if given Nickel index is correct(minimal).

    // When drupal executes a script, it starts in the project path e.g.
    // /var/www/html/drupal_project/ , where the "sites/" folder is.
    $exec1 = "python sites/default/scripts/minimalnickel.py " .
               escapeshellarg($nickel_value_given) .
               " 2>&1";
    $nickel_value_correct = trim(shell_exec($exec1)); // Correct Nickel
                            // Index calculated by script.  trim() was
                            // needed here because shell_exec() produces
                            // one unwanted whitespace at the end of the
                            // output string


    if ( strlen($nickel_value_given) != strlen($nickel_value_correct) )
    {
      // GraphState outputs a (long) error message if the nickel string
      // argument is wrong according to the convention. So if the output
      // of the script has not the same length as the given nickel
      // string, something went wrong.

      form_set_error('lop_nickel', t(
        'Your nickel index "@ni_given" seems to be wrong. Please check if it is according to the conventions.',
        array(
        '@ni_given' => $nickel_value_given,
        )
      ));
    }
    elseif ( $nickel_value_given != $nickel_value_correct )
    {
      // If the given string has the same length as the outupt but is
      // not equal, then the given nickel index is not minimal.

      // So we write the corret nickel index to the appropriate places:
      // $form_state['values'] storet the real value that is used
      // further.
      $form_state['values']['lop_nickel']['und'][0]['value'] = $nickel_value_correct;
      // $form_state['input'] apparently stores the user input. This is
      // printed on the screen.
      $form_state['input']['lop_nickel']['und'][0]['value'] = $nickel_value_correct;
      // // form_set_value() does not work as I expect.
      // form_set_value($form['nickel_adjalist']['lop_nickel'], 'blabla', $form_state);


      // Now we print out a message, that the Nickel Index was changed
      // to the correct version:
      drupal_set_message(t('The given nickel index: "@ni_given" is not correct (minimal). It was replaced by the correct (minimal) Nickel index: <strong>"@ni_correct"</strong>.',
        array(
          '@ni_given' => $nickel_value_given,
          '@ni_correct' => $nickel_value_correct,
        )
      ));
    }
    else
    {
      drupal_set_message(t('The Nickel index "@nickel" is correct!',
        array('@nickel' => $nickel_value_correct)
      ));
    }
  }
  // End of checking the Nickel index.

}
// End of loopedia_integral_next_validate_1()



/**
 * Submit handler for loopedia_integral_first_step next button.
 */
function loopedia_integral_next_submit_1(&$form, &$form_state)
{
  $nickel = $form_state['values']['lop_nickel']['und'][0]['value'];
  // Generate Picture to Nickel Index
  $image_path = "sites/default/files/nickel_generated/" .
                  uniqid($nickel);
                 // this is the path to the dot file the image (svg)
                 // file will have an extra ending of ".svg"
  $script_path = "sites/default/scripts/neato_from_nickel.py";
  $exec2 = escapeshellcmd("python $script_path " . $nickel . " $image_path");
  exec($exec2);
  // Save image path in 'lop_picture_path'. $image_path looks like
  // 'sites/default/files/...'. We have to prefix this with
  // 'http://localhost/loopediatest/' in order to get an "absoulte" path
  // to the file. This is necessary because while editing a node, drupal
  // starts with the path 'http://localhost/loopediatest/node/52/edit',
  // for some reason. So we need an absolute path.
  $form_state['values']['lop_picture_path']['und'][0]['value'] = 'http://localhost/loopediatest/' . $image_path . ".svg";


  // Extract information out of the Nickel Index string and save it to
  // the appropriate fields:
  $legs = substr_count($nickel, 'e');
  $form_state['values']['lop_leg_number']['und'][0]['value'] = $legs;
  $form_state['input']['lop_leg_number']['und'][0]['value'] = $legs;

  $propagators = preg_match_all('~[0-9A-Z]~', $nickel);
  $form_state['values']['lop_propagator_number']['und'][0]['value'] = $propagators;
  $form_state['input']['lop_propagator_number']['und'][0]['value'] = $propagators;

  $vertices = substr_count($nickel, '|');
  $form_state['values']['lop_vertex_number']['und'][0]['value'] = $vertices;
  $form_state['input']['lop_vertex_number']['und'][0]['value'] = $vertices;

  $loops = $propagators - $vertices + 1;
  $form_state['values']['lop_loop_number']['und'][0]['value'] = $loops;
  $form_state['input']['lop_loop_number']['und'][0]['value'] = $loops;



  // We set 'step' to 2 such that when the form gets build next time,
  // it will build the second step
  $form_state['step'] = 2;
  $form_state['rebuild'] = TRUE;
}




// /**
//  *  Validate handler for the nickel index
//  */
// function loopedia_lop_nickel_validate($element, $form_state)
// {
//   // dpm($element, '$element');
// }



// ********************************************************************
// Second step:

/**
 * Callback function for the second step of the integral sumbission form.
 */
function loopedia_integral_second_step(&$form, &$form_state)
{
  $elements_to_show = array(
    'lop_nickel',
    'lop_leg_number',
    'lop_vertex_number',
    'lop_loop_number',
    'lop_propagator_number',
  );
  $num_legs = $form_state['values']['lop_leg_number']['und'][0]['value'];
  for ($i = 1; $i <= $num_legs; $i++)
  {
    $elements_to_show[] = 'lop_ext_leg_' . $i . '_virt';
  }
  //
  $num_prop = $form_state['values']['lop_propagator_number']['und'][0]['value'];
  for ($i = 1; $i <= $num_prop; $i++)
  {
    $elements_to_show[] = 'lop_propagator_' . $i . '_mass';
    $elements_to_show[] = 'lop_propagator_' . $i . '_power';
  }

  _loopedia_display_fields($elements_to_show, $form, $form_state);

  $form['feynman_graph'] = array(
    '#type' => 'markup',
    '#markup' => '<img src="'.
      $form_state['values']['lop_picture_path']['und'][0]['value'] .
      ' "alt="alternative text">',
    '#weight' => 10,
  );


  $form['leg_virtuality'] = array(
    '#type' => 'fieldset',
    '#title' => 'Virtualities of external legs',
    '#description' => 'Choose the virtuality of the external legs. The choices are:
       <ul>
        <li>light-like : p^2 = 0</li>
        <li>on_internal_mass_shell : p^2 &ne; 0. But p is on a mass shell of one of the (internal) propagators: p^2 = m_j.</li>
        <li>off-shell: p is not light like and also not on one of the internal mass shells.</li>
      </ul> ',
    '#collapsible' => false,
    '#weight' => 50,
  );
  //
  $legs = $form_state['values']['lop_leg_number']['und'][0]['value'];
  for ($i = 1; $i <= $legs; $i++)
  {
    $form['lop_ext_leg_' . $i . '_virt']['und']['#required'] = true;
    $form['leg_virtuality']['lop_ext_leg_' . $i . '_virt'] = $form['lop_ext_leg_' . $i . '_virt'];
    unset($form['lop_ext_leg_' . $i . '_virt']);
  }

  // Propagators:

  $form['propagators'] = array(
    '#type' => 'fieldset',
    '#title' => 'Properties of Propagators',
    '#description' => 'Please set masses and powers of propagators.',
    '#weight' => 11,
    '#collapsible' => false,
  );

  $props = $form_state['values']['lop_propagator_number']['und'][0]['value'];
  for ($i = 1; $i <= $props; $i++)
  {
    $form['propagators']['propagator' . $i] = array(
      '#type' => 'fieldset',
      '#title' => 'Propagator ' . $i . ' (P' . $i . ')',
      '#description' => '',
      '#collapsible' => false,
      '#weight' => 10 + $i,
    );
    // Set this field as a required field. This way, the user is not allowed to select "-None-"
    $form['lop_propagator_' . $i . '_mass']['und']['#required'] = true;
    // Copy field definition to fieldset
    $form['propagators']['propagator' . $i]['lop_propagator_' . $i . '_mass'] = $form['lop_propagator_' . $i . '_mass'];
    // Delete original field definiton
    unset($form['lop_propagator_' . $i . '_mass']);
    //
    // Do the same for power as above for mass
    $form['lop_propagator_' . $i . '_power']['und'][0]['value']['#required'] = true;
    $form['propagators']['propagator' . $i]['lop_propagator_' . $i . '_power'] = $form['lop_propagator_' . $i . '_power'];
    unset($form['lop_propagator_' . $i . '_power']);
  }

  // Buttons:

  $form['actions']['back'] = array(
    '#type' => 'submit',
    '#value' => t('<< Back'),
    '#submit' => array('loopedia_integral_back_submit_2'),
    //
    // We don't want to validate the fields because they will be
    // validated once the user goes forward. #limit_validation_errors()
    // takes an array of elements that will be validated. Everything
    // else will not be validated. See
    // https://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#limit_validation_errors
    '#limit_validation_errors' => array(),
  );

  $form['actions']['next'] = array(
    '#type' => 'submit',
    '#value' => 'Next >>',
    '#submit' => array('loopedia_integral_next_submit_2'),
    // '#validate' => array('form_example_tutorial_8_next_validate'),
  );
  $form['actions']['submit']['#attributes']['class']['hide_me'] = 'element-hidden';
}

/**
 * Submit handler for loopedia_integral_second_step next button.
 */
function loopedia_integral_next_submit_2(&$form, &$form_state)
{
  $form_state['step'] = 3;
  $form_state['rebuild'] = TRUE;
}

/**
 * Submit handler for loopedia_integral_second_step back button.
 */
function loopedia_integral_back_submit_2(&$form, &$form_state)
{
  $form_state['step'] = 1;
  $form_state['rebuild'] = TRUE;
}



/**
 * Callback function for the third step of the integral sumbission form.
 */
function loopedia_integral_third_step(&$form, &$form_state)
{
  dsm('this is step three!');
}


/**
 * Submit handler for loopedia_integral_third_step back button.
 */
function loopedia_integral_back_submit_3(&$form, &$form_state)
{
  $form_state['step'] = 2;
  $form_state['rebuild'] = TRUE;
}


/**
 * Callback function for extra form validation of the integral node
 * type.
 */
function loopedia_lop_integral_form_validate($form, &$form_state)
{
  dsm('I am loopedia_lop_integral_form_validate ' . microtime(true) );
  dpm($form_state, '$form_state');
  dpm($form, '$form');
}



//**********************************************************ooo

function loopedia_node_view_alter(&$build)
{
  dpm($build);
}



/**
* Implements of hook_init().
*
* This function can be used for dirty debugging because it is executed
* on all page requests that are not cached.
*/
function loopedia_init() {
  // $arr = array();
  // $i = 13;
  // $arr['bla' . $i . 'blub'] = 'yes' . ' no' . $i . ' maybe';
  // dpm($arr);
  // drupal_set_message('Beware I live!');
  // $types = node_type_get_types();
  // dpm($types);
  //
  // $type = node_type_load('lop-integral');
  // dpm($type);
  // $instance_info = field_info_instance('node', 'field_blabla', 'article');
  // dpm($instance_info);
  //
  // $fieldinfo = field_info_field('loopedia_term_reference');
  // dpm($fieldinfo);
  // dpm(hook_field_storage_info());
}
