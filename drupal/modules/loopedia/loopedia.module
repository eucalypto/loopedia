<?php

/**
 * @file
 * Module file for my Loopedia Module
 */



/**
 * Implements hook_node_info().
 *
 * We use hook_node_info() to define the loopedia node content type.
 */
function loopedia_node_info()
{
  return array(
    'lop_integral' => array(
      'name' => t('Integral'),
      // 'base' should be the (machine) name of the module. If it is
      // not, this content type will not appear in structure -> content
      // type.
      'base' => 'loopedia',
      'description' => t('This is the node type for Feynman Integrals'),
      'has_title' => '1',
      'title_label' => t('Integral Title'),
      'help' => t('This is an explanation that should help you.')
    ),
  );
}


/**
 * Implements hook_form().
 *
 * This is the form that the user sees when he wants to upload an integral.
 *
 */
function loopedia_form($node, $form_state) {
  // node_content_form() is the standard function that returns a form. It is
  // provided by the "node" module.
  return node_content_form($node, $form_state);
}


/** Implements hook_form_alter().
 *
 */
function loopedia_form_alter(&$form, &$form_state, $form_id)
{
  // dpm($form_id, '$form_id');
  // dpm($form, '$form');
  // dpm($form_state, '$form_state');
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Here, we want to change the standard submission form to a more custom
 * version.
 */
function loopedia_form_lop_integral_node_form_alter(&$form, &$form_state, $form_id)
{
  // Add an extra validate function
  $form['#validate'][] = $form['#validate'][0];
  $form['#validate'][0] = 'loopedia_lop_integral_form_validate';

  // Here we try to auto-check the checkbox that triggers a revision
  // control
  $form['revision_information']['revision']['#default_value'] = 1;



  // // We want so set a value for a field through our srcipts. But the
  // // user still wants to see the value that we put in. The way to go is
  // // this. Define "#default_value" here in form_alter() and it will be
  // // put into the generated form.
  // $form['lop_light_like_leg_number']['und'][0]['value']['#default_value'] = '123';




  // // If you want to hide a field in a form, this seems like the way to
  // // go. You define an '#attributes' to a field  in the following
  // // manner. This just marks the form invisible in css. If the user
  // // turns css off, he still can see the field. See
  // // http://drupal.stackexchange.com/questions/7199/how-to-hide-and-or-prevent-access-to-fields-in-a-form-such-as-group-audience-f
  // // This way, you can still populate a field with #default_value and it
  // // will even be validated.
  // //
  // // An alternative way could be using '#prefix'
  // // and '#suffix' according to https://www.drupal.org/node/728398
  // $form['lop_leg_number']['#attributes']['class']['hide_me'] = 'element-hidden';
  // $form['lop_leg_number']['und'][0]['value']['#default_value'] = 'b200';


  // We control the steps of the form with $form_state['step']. If it is
  // not set, we must be on the first page. So we set it to 1. If
  // it is set, we obviously don't want to change it here.
  if (!isset($form_state['step']))
  {
    $form_state['step'] = 1;
  }


  // Decide what to do according to the 'step' variable:
  switch ($form_state['step'])
  {
    case 1:
      // Do something for the first page
      loopedia_integral_first_step($form, $form_state);
      break;
    case 2:
      // Do something for the second page
      loopedia_integral_second_step($form, $form_state);
      break;
    case 3:
      loopedia_integral_third_step($form, $form_state);
      break;
  }



  // // Here, we put the two fields for each propagator into one fieldset.
  // for ($i = 1; $i <= 12; $i++)
  // {
  //   $form['prop_' . $i] = array(
  //     '#type' => 'fieldset',
  //     '#title' => 'Propagator ' . $i,
  //     '#description' => t('This is the description of the fieldset for the Propagator.'),
  //     '#collapsible' => false,
  //     'lop_propagator_' . $i . '_mass' => $form['lop_propagator_' . $i . '_mass'],
  //     'lop_propagator_' . $i . '_power' => $form['lop_propagator_' . $i . '_power'],
  //     // '#weight' => -4,
  //   );
  //   unset($form['lop_propagator_' . $i . '_mass'],
  //         $form['lop_propagator_' . $i . '_power']);
  // }

  // dpm($form_state, '$form_state');
  dpm($form, '$form');
}


/**
 * Callback function for the first step of the integral sumbission form.
 */
function loopedia_integral_first_step(&$form, &$form_state)
{
  // Here, we write the names of all elements that need to be hidden in
  // an array.
  $elements_to_hide = array(
    'lop_comment',
    // 'lop_nickel',
    'lop_literature_arxiv',
    'lop_literature_publication',
    'lop_int_mass_shell_leg_num',
    'lop_leg_number',
    'lop_light_like_leg_number',
    'lop_loop_number',
    'lop_mass_scale_number',
    'lop_massless_propagator_number',
    'lop_off_shell_leg_number',
    'lop_propagator_number',
  );
  // Adding the external leg virtualities to $elements_to_hide :
  for ($i = 1; $i <= 20; $i++)
  {
    $elements_to_hide[] = 'lop_ext_leg_' . $i . '_virt';
  }
  // Adding the mass and power fields for the propagators:
  for ($i = 1; $i <= 12; $i++)
  {
    $elements_to_hide[] = 'lop_propagator_' . $i . '_mass';
    $elements_to_hide[] = 'lop_propagator_' . $i . '_power';
  }

  // Here, we write the appopriate array elements to the elements to
  // hide.
  foreach ($elements_to_hide as $hide_me)
  {
    $form[$hide_me]['#attributes']['class']['hide_me'] = 'element-hidden';
  }


  $form['actions']['next'] = array(
    '#type' => 'submit',
    '#value' => 'Next >>',
    '#submit' => array('loopedia_integral_next_submit'),
    // '#validate' => array('form_example_tutorial_8_next_validate'),
  );
  $form['actions']['submit']['#attributes']['class']['hide_me'] = 'element-hidden';
}


/**
 * Callback function for the second step of the integral sumbission form.
 */
function loopedia_integral_second_step(&$form, &$form_state)
{
  dsm('This is second step function.');
  $form['actions']['back'] = array(
    '#type' => 'submit',
    '#value' => t('<< Back'),
    '#submit' => array('loopedia_integral_back_submit'),
    //
    // We don't want to validate the fields because they will be
    // validated once the user goes forward. #limit_validation_errors()
    // takes an array of elements that will be validated. Everything
    // else will not be validated. See
    // https://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#limit_validation_errors
    '#limit_validation_errors' => array(),
  );

  $form['actions']['next'] = array(
    '#type' => 'submit',
    '#value' => 'Next >>',
    '#submit' => array('loopedia_integral_next_submit'),
    // '#validate' => array('form_example_tutorial_8_next_validate'),
  );
  $form['actions']['submit']['#attributes']['class']['hide_me'] = 'element-hidden';
}


/**
 * Callback function for the third step of the integral sumbission form.
 */
function loopedia_integral_third_step(&$form, &$form_state)
{
  dsm('this is step three!');
}



/**
 * Submit handler for loopedia_integral_first_step next button.
 */
function loopedia_integral_next_submit(&$form, &$form_state)
{
  switch ($form_state['step'])
  {
    case 1:
      // We set 'step' to 2 such that when the form gets build next time,
      // it will build the second step
      $form_state['step'] = 2;
      break;
    case 2:
      $form_state['step'] = 3;
      break;
  }
  $form_state['rebuild'] = TRUE;
}

/**
 * Submit handler for loopedia_integral_first_step next button.
 */
function loopedia_integral_back_submit(&$form, &$form_state)
{
  switch ($form_state['step'])
  {
    case 2:
      $form_state['step'] = 1;
      break;
    case 3:
      $form_state['step'] = 2;
      break;
  }
  $form_state['rebuild'] = TRUE;
}




/**
 * Callback function for extra form validation of the integral node
 * type.
 */
function loopedia_lop_integral_form_validate($form, &$form_state)
{
  dsm('I am loopedia_lop_integral_form_validate ' . microtime(true) );
  dpm($form_state, '$form_state');
  dpm($form, '$form');
}




/**
* Implements of hook_init().
*
* This function can be used for dirty debugging because it is executed
* on all page requests that are not cached.
*/
function loopedia_init() {
  // $arr = array();
  // $i = 13;
  // $arr['bla' . $i . 'blub'] = 'yes' . ' no' . $i . ' maybe';
  // dpm($arr);
  // drupal_set_message('Beware I live!');
  // $types = node_type_get_types();
  // dpm($types);
  //
  // $type = node_type_load('lop-integral');
  // dpm($type);
  // $instance_info = field_info_instance('node', 'field_blabla', 'article');
  // dpm($instance_info);
  //
  // $fieldinfo = field_info_field('loopedia_term_reference');
  // dpm($fieldinfo);
  // dpm(hook_field_storage_info());
}
