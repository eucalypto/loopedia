<?php

/**
 * @file
 * Module file for my Nickel play module
 */


/**
 * Implements hook_menu().
 */
function nickelplay_menu()
{
  $items = array();

  $items['generate_graph'] = array( // This creates a URL that
                                // will call this form at "nickelplay"
    'title' => 'Generate Graph', //page title
    'description' => 'A form for playing with graph identifiers.',
    'page callback' => 'drupal_get_form',  // This is the function that will
                                           // be called when the page is
                                           // accessed.  for a form, use
                                           // drupal_get_form
    'page arguments' => array('nickelplay_form'),
    'access callback' => TRUE,
  );

  return $items;
}



function nickelplay_form($form, &$form_state)
{
  // This is how you insert HTML into a form:
  // $form['html_text'] = array(
  //   '#markup' => t('<p>Hello there. You are reading me right now!</p>')
  // );

  $form['guidance'] = array(
    '#type' => 'fieldset',
    '#title' => t('Help with Adjacency List or Nickel Index'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['guidance']['adjalist'] = array(
    '#type' => 'item',
    '#title' => t('Adjacency List'),
    '#description' => t(
      'An adjacency list is a list of connections between vertices. Please label the vertices after a non-negative integers (0, 1, 3, 23, ...). External legs can be labelled with negative numbers like "-1", "-2", "-3".<br> An example of an adjacency list would be "[-1, 1], [1, 2], [1, 2], [1, 2], [2, -2]" for the Sunrise diagram.'
    ),
  );

  $form['guidance']['nickel'] = array(
    '#type' => 'item',
    '#title' => t('Nickel Index'),
    '#description' => t(
      'A Nickel Index is a string consisting of several parts. For <strong>each</strong> vertex there exists one part which <em>must</em> be closed with a vertical bar "|". The vertices are numbered the programmer\'s style: the first one gets the number zero (0) and so on. So the first part of the nickel index lists the vertices that are connected to the first (0) vertex -- external connections are denoted with "e". The second part lists all connections of the second (1) vertex except the previous established connections with the first vertex. This goes on. In each part only new connections (lines) are written down such that in the whole nickel string every line is denoted by exactly one character (number or "e"). <br />Now by permuting the vertex numbers one can find a particular "minimal" index. This is called the (true) Nickel Index. This Nickel Index is explained in more detail in the paper of <a href="@batkov-arxiv">Batkovich et al.</a> As an example the Nickel Index of the sunrise diagram woud be "<strong>e111|e|</strong>".<br>As another example consider the following Nickel index: "<strong>e123|e23|e3||</strong>". This diagram has four vertices. Thus there are four parts in the Nickel index closed off with a vertical bar | including the last one, which contains no <em>new</em> connections.',
    array('@batkov-arxiv' => 'http://arxiv.org/abs/1409.8227')
    ),
  );

  $form['input'] = array(
    '#type' => 'textfield',
    '#title' => 'Graph Identifier',
    '#description' => 'Type a Nickel Index or an Adjacency List',
    '#size' => 80,
    '#required' => TRUE, //make this field required
  );


  // dpm($form_state);
  if (isset($form_state['imagepath']))
  {
    if ($form_state['input_type'] == 'adjalist')
    {
      $form['calculatednickel'] = array(
        '#type' => 'item',
        '#title' => t('Correspondung Nickel Index: "@nickel"', array(
          '@nickel' => $form_state['nickel'],
        )),
      );
    }

    $form['html_text1'] = array(
      '#markup' => t('<img src="'. $form_state['imagepath'] .
                      '" alt="generated_graph">')
      );
  }

  $form['submit_button'] = array(
    '#type' => 'submit',
    '#value' => t('Generate Graph!'),
  );

  // dpm($form);
  // dpm($form_state);

  return $form;
}


/**
 * Implements hook_form_validate().
 *
 * This is where the validation of the entries happens.
 */
function nickelplay_form_validate($form, &$form_state)
{
  $graph_id = $form_state['values']['input'];
  $validated_nickel = nickelplay_integral_form_identifier_validation($graph_id);

  if ($validated_nickel['input_type'] === 'nickel')
  {
    $form_state['input_type'] = 'nickel';

    // React to different error messages:
    switch ($validated_nickel['error_code'])
    {
      case 'nickel_forbidden_characters':
        form_set_error('input', t('Your Nickel Index seems to contain other characters than the allowed: "e", "0-9", "A-Z", "|".'));
        break;
      case 'nickel_wrong_convention':
        form_set_error('input', t(
          'Your nickel index "@ni_given" seems to be wrong. Please check if it is according to the conventions.',
          array(
          '@ni_given' => $graph_id,
          )
        ));
        break;
      case 'nickel_non_minimal':
        drupal_set_message(t('The given nickel index: "@ni_given" is not correct (minimal). It was replaced by the correct (minimal) Nickel index: <strong>"@ni_correct"</strong>.',
          array(
            '@ni_given' => $graph_id,
            '@ni_correct' => $validated_nickel['nickel_correct'],
          )
        ));
        break;
      case 'nickel_correct':
        drupal_set_message(t('The Nickel index "@nickel" is correct!',
          array('@nickel' => $validated_nickel['nickel_correct'])
        ));
        break;
    }
    $form_state['nickel'] = $validated_nickel['nickel_correct'];
  }
  else if ($validated_nickel['input_type'] === 'adjalist')
  {
    $form_state['input_type'] = 'adjalist';
    $adjalist = &$graph_id;
    switch ($validated_nickel['error_code'])
    {
      case 'adjalist_forbidden_characters':
        form_set_error('graph_id', t(
        'Your adjacency list seems to contain not allowed characters. The allowed ones are: "[comma]", "-", "[", "]", "0-9", "[whitespace]"'
        ));
        break;
      case 'adjalist_general_problem':
        form_set_error('graph_id', t(
          "There seems to be a problem with your adjacency list."
        ));
        break;
      case 'adjalist_success':
        $form_state['nickel'] = $validated_nickel['nickel_correct'];
        break;
    }
  }
}
// End of nickelplay_form_validate()



/**
 * Implements hook_form_submit()
 *
 * Here is everything that is not just validation of the user input.
 */
function nickelplay_form_submit($form, &$form_state)
{
  $nickel = &$form_state['nickel'];
  // Generate Picture to Nickel Index
  $image_path = "sites/default/files/tmp/" . uniqid($nickel);
                 // this is the path to the dot file the image (svg) file will
                 // have an extra ending of ".svg"
  $script_path = "sites/default/scripts/neato_from_nickel.py";
  $exec2 = escapeshellcmd("python $script_path " . $nickel .
                           " $image_path");
  exec($exec2);
  $form_state['imagepath'] = $GLOBALS['base_url'] . '/' . $image_path . ".svg";

  // drupal_set_message('This should only appear when no error is given!<br />' . $exec2);

  $form_state['rebuild'] = TRUE;
}


/** Implements hook_form_alter().
 *
 * This hook is executed on every form page.
 */
function nickelplay_form_alter(&$form, &$form_state, $form_id)
{
  // dpm($form_id, '$form_id');
  // dpm($form, '$form');
  // dpm($form_state, '$form_state');
}


/**
 * Implements hook_permission()
 *
 * This function adds a new permission that is supposed to manage
 * reference (comment) deletion. For this, we have to somehow alter the
 * function comment_links($comment, $node) from the core module
 * "comment". I haven't done this yet; until then, this definition is
 * useless. This overrride of the links-function is just of cosmetic
 * nature and should not affect the stored integral data (in database);
 * so this can be done later and is not a priority.
 */
function nickelplay_permission()
{
  return array(
    'loopedia delete own reference' => array(
      'title' => t('Delete own references (Comments)'),
      'description' => t('This permission is meant for the "Comments"-section of permissions. It manages the permission to delete own references, which are stored as comments.'),
    ),
  );
}


/**
 * Implements hook_menu_alter().
 */
function nickelplay_menu_alter(&$items)
{
  unset($items['comment/%/view']);
  // $items['comment/%/delete']['access arguments'] = array('edit', 1);
  // $items['comment/%/delete']['access callback'] = 'comment_access';
}


// ***********************************
// Begin: Adjust comments for Integral

/**
 * Implements hook_form_FORM_ID_alter()
 *
 * FORM_ID = comment_node_lop_integral_form
 *
 * Change submission form for integral comments
 */
function nickelplay_form_comment_node_lop_integral_form_alter(&$form, &$form_state, $form_id)
{
  unset($form['subject']);
  unset($form['actions']['preview']);

  // The Comment module requires the field comment_body. But we do not
  // want it; we remove it from the form. See
  // https://www.drupal.org/node/1038652
  $form['comment_body']['#attributes']['class'][] = 'element-hidden';

  dpm($form);
}

/**
 * Implements hook_comment_view_alter(&$build)
 *
 * The comment was built; the module may modify the structured content.
 *
 * This hook is called after the content has been assembled in a
 * structured array and may be used for doing processing which requires
 * that the complete comment content structure has been built.
 *
 * If the module wishes to act on the rendered HTML of the comment
 * rather than the structured content array, it may use this hook to add
 * a #post_render callback.
 * Alternatively, it could also implement hook_preprocess_comment(). See
 * drupal_render() and theme() documentation respectively for details.
 *
 * @param $build
 *   A renderable array representing the comment.
 *
 * @see comment_view()
 * @see hook_entity_view_alter()
 */
function nickelplay_comment_view_alter(&$build)
{
  // Remove reply link
  unset($build['links']['comment']['#links']['comment-reply']);

  // Remove link for "login or register"
  unset($build['links']['comment']['#links']['comment_forbidden']);

  // dpm($build);
}

/**
 * Implements hook_node_view_alter()
 *
 * Alter the results of node_view().
 *
 * This hook is called after the content has been assembled in a structured
 * array and may be used for doing processing which requires that the complete
 * node content structure has been built.
 *
 * If the module wishes to act on the rendered HTML of the node rather than the
 * structured content array, it may use this hook to add a #post_render
 * callback.  Alternatively, it could also implement hook_preprocess_node(). See
 * drupal_render() and theme() documentation respectively for details.
 *
 * @param $build
 *   A renderable array representing the node content.
 *
 * @see node_view()
 * @see hook_entity_view_alter()
 *
 * @ingroup node_api_hooks
 */
function nickelplay_node_view_alter(&$build)
{
  if ($build['#bundle'] == 'lop_integral')
  {
    // Adjust links for comments (references)
    nickelplay_lop_integral_view_comment_links($build);



    // Feynman Graph
    // If internal stuff is displayed (set):
    // - Read out the path of the generated picture
    // - Add picture to build array as markup element
    // - Unset internal stuff element (hide it)
    if (isset($build['field_lop_internal_stuff']))
    {
      $path = '';
      $int_stuff = &$build['field_lop_internal_stuff'][0]['entity']['field_collection_item'];
      foreach ($int_stuff as &$dummy)
      {
        $path = $dummy['field_lop_picture_path']['#object']->field_lop_picture_path['und'][0]['value'];
      }
      // Display generated Feynman Graph
      $build['feynman_graph'] = array(
        '#type' => 'markup',
        '#prefix' => '<img src="',
        '#markup' => $path,
        '#suffix' => '" alt="Generated Feynman Graph">',
        '#weight' => -1,
      );
      unset($build['field_lop_internal_stuff']);
    }

    dpm($build);
  }
}

/**
 * Helper function that adjusts reference (comment) links in lop
 * integral; called from nickelplay_node_view_alter(&$build).
 *
 * @param the same array that nickelplay_node_view_alter() gets
 */
function nickelplay_lop_integral_view_comment_links(&$build)
{
  // Adjust "Add new reference" link
  if (isset($build['links']['comment']['#links']['comment-add']))
  {
    $build['links']['comment']['#links']['comment-add']['title'] = 'Add reference';
    $build['links']['comment']['#links']['comment-add']['attributes']['title'] = 'Add new reference and/or result to this integral.';
  }

  // Remove line about "login/register to post links"
  unset($build['links']['comment']['#links']['comment_forbidden']);

  // Remove link to comments only
  unset($build['links']['comment']['#links']['comment-comments']);

  // Remove link "new comments"
  unset($build['links']['comment']['#links']['comment-new-comments']);
}



// /**
//  * The comment is being viewed. This hook can be used to add additional data to the comment before theming.
//  *
//  * @param $comment
//  *   Passes in the comment the action is being performed on.
//  * @param $view_mode
//  *   View mode, e.g. 'full', 'teaser'...
//  * @param $langcode
//  *   The language code used for rendering.
//  *
//  * @see hook_entity_view()
//  */
// function nickelplay_comment_view($comment, $view_mode, $langcode)
// {
//   dpm($comment);
//   dpm($view_mode);
// }

// /**
//  * Implements hook_preprocess_comment().
//  */
// function nickelplay_preprocess_comment(&$vars)
// {
//   // unset($vars['permalink']);
//   // unset($vars['submitted']);
//   dpm($vars);
// }



// End: Adjust comments for Integral
// *********************************




// ***************************************
// Begin: Functions for Integral node form

/**
 * Implements hook_form_FORM_ID_alter()
 *
 * FORM_ID = lop_integral_node_form
 * Here, we want to change the standard submission form to a more custom
 * version.
 */
function nickelplay_form_lop_integral_node_form_alter(&$form, &$form_state, $form_id)
{


  // We control the steps of the form with $form_state['step']. If it is
  // not set, we must be on the first page. So we set it to 1. If
  // it is set, we obviously don't want to change it here.
  if (!isset($form_state['step']))
  {
    $form_state['step'] = 1;
  }

  // Decide what to do according to the 'step' variable:
  switch ($form_state['step'])
  {
    case 1:
      nickelplay_integral_first_step($form, $form_state);
      break;
    case 2:
      nickelplay_integral_second_step($form, $form_state);
      break;
    case 3:
      nickelplay_integral_third_step($form, $form_state);
      break;
  }

  // To set a value to a field that the user cannot change, set '#value'
  // instead of '#default_value'. https://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7.x#value
  // unset($form['field_lop_input']['und'][0]['value']['#default_value']);
  // $form['field_lop_input']['und'][0]['value']['#value'] = '[blablabbbbb]';

  dpm($form);
  // dpm($form_state);
}

/**
 * Hides element by writing $element['#attributes']['class'][] = 'element-hidden';
 *
 * @param array of references $elements
 *   This array should contain references to elements in $form
 */
function nickelplay_hide_elements(&$elements)
{
  foreach ($elements as &$element)
  {
    $element['#attributes']['class'][] = 'element-hidden';
  }
  // Make sure to get rid of dummy reference variable:
  unset($element);
}


/**
* Callback function for the first step of the integral submission form.
*/
function nickelplay_integral_first_step(&$form, &$form_state)
{
  // Hide some elements
  $elements = array(
    &$form['field_lop_props'],
    &$form['field_lop_legs_virt'],
    &$form['field_lop_topo_num'],
    &$form['field_lop_internal_stuff'],
    &$form['field_lop_color_num'],
  );
  nickelplay_hide_elements($elements);


  // Buttons:
  $form['actions']['next'] = array(
   '#type' => 'submit',
   '#value' => 'Next >>',
   '#submit' => array('nickelplay_integral_next_submit_1'),
   '#validate' => array('nickelplay_integral_next_validate_1'),
  );
  $form['actions']['submit']['#attributes']['class'][] = 'element-hidden';
}


/**
 * Validate handler for nickelplay_integral_first_step next button
 *
 * It might become important, in which order the validation functions
 * are executed. Then, you should experiment with it.
 *
 */
function nickelplay_integral_next_validate_1(&$form, &$form_state)
{
  // $graph_id = &$form_state['values']['lop_input']['und'][0]['value'];
  $graph_id = &$form_state['values']['field_lop_input']['und'][0]['value'];

  $validated_nickel = nickelplay_integral_form_identifier_validation($graph_id);

  if ($validated_nickel['input_type'] === 'nickel')
  {
    // React to different error messages:
    switch ($validated_nickel['error_code'])
    {
      case 'nickel_forbidden_characters':
        form_set_error('field_lop_input', t('Your Nickel Index seems to contain other characters than the allowed: "e", "0-9", "A-Z", "|".'));
        break;
      case 'nickel_wrong_convention':
        form_set_error('field_lop_input', t(
          'Your nickel index "@ni_given" seems to be wrong. Please check if it is according to the conventions.',
          array(
          '@ni_given' => $graph_id,
          )
        ));
        break;
      case 'nickel_non_minimal':
        drupal_set_message(t('The given nickel index: "@ni_given" is not correct (minimal). It was replaced by the correct (minimal) Nickel index: <strong>"@ni_correct"</strong>.',
          array(
            '@ni_given' => $graph_id,
            '@ni_correct' => $validated_nickel['nickel_correct'],
          )
        ));
        break;
      case 'nickel_correct':
        drupal_set_message(t('The Nickel index "@nickel" is correct!',
          array('@nickel' => $validated_nickel['nickel_correct'])
        ));
        break;
    }
    // Write correct Nickel to appropiate places
    // $form_state['values']['field_lop_topo_num']['und'][0]['field_lop_nickel']['und'][0]['value'] = $validated_nickel['nickel_correct'];
    // $form_state['input']['field_lop_topo_num']['und'][0]['field_lop_nickel']['und'][0]['value'] = $validated_nickel['nickel_correct'];
    $form_state['topo_nums']['field_lop_nickel'] = $validated_nickel['nickel_correct'];
  }
  else if ($validated_nickel['input_type'] === 'adjalist')
  {
    $form_state['input_type'] = 'adjalist';
    $adjalist = &$graph_id;
    switch ($validated_nickel['error_code'])
    {
      case 'adjalist_forbidden_characters':
        form_set_error('field_lop_input', t(
        'Your adjacency list seems to contain not allowed characters. The allowed ones are: "[comma]", "-", "[", "]", "0-9", "[whitespace]"'
        ));
        break;
      case 'adjalist_general_problem':
        form_set_error('field_lop_input', t(
          "There seems to be a problem with your adjacency list."
        ));
        break;
      case 'adjalist_success':
        // Write generated (correct) Nickel to appropiate places
        // $form_state['values']['field_lop_topo_num']['und'][0]['field_lop_nickel']['und'][0]['value'] = $validated_nickel['nickel_correct'];
        // $form_state['input']['field_lop_topo_num']['und'][0]['field_lop_nickel']['und'][0]['value'] = $validated_nickel['nickel_correct'];
        $form_state['topo_nums']['field_lop_nickel'] = $validated_nickel['nickel_correct'];
        break;
    }
  }
  dpm($form_state);
// End of loopedia_integral_next_validate_1()
}


/**
 * Submit handler for loopedia_integral_first_step next button.
 */
function nickelplay_integral_next_submit_1(&$form, &$form_state)
{
  // $nickel = $form_state['values']['field_lop_topo_num']['und'][0]['field_lop_nickel']['und'][0]['value'];
  $nickel = $form_state['topo_nums']['field_lop_nickel'];
  // Generate Picture to Nickel Index
  $image_path = "sites/default/files/nickel_generated/tmp/" .
                  uniqid($nickel);
                 // this is the path to the dot file the image (svg)
                 // file will have an extra ending of ".svg"
  $script_path = "sites/default/scripts/neato_from_nickel.py";
  $exec2 = escapeshellcmd("python $script_path " . $nickel . " $image_path");
  exec($exec2);
  // Save image path in 'lop_picture_path'. $image_path looks like
  // 'sites/default/files/...'. We have to prefix this with something
  // like 'http://localhost/loopediatest/' in order to get an "absoulte"
  // path to the file. This is necessary because while editing a node,
  // drupal starts with the path
  // 'http://localhost/loopediatest/node/52/edit', for some reason. So
  // we need an absolute path.
  //
  // http://localhost/loopediatest is the base url for my test drupal
  // installation. To make this code portable, use the global variable
  // $GLOBALS['base_url'], which stores exactly what we need.
  $form_state['values']['field_lop_internal_stuff']['und'][0]['field_lop_picture_path']['und'][0]['value'] = $GLOBALS['base_url'] . '/' . $image_path . ".svg";
  $form_state['input']['field_lop_internal_stuff']['und'][0]['field_lop_picture_path']['und'][0]['value'] = $GLOBALS['base_url'] . '/' . $image_path . ".svg";





  // // Extract information out of the Nickel Index string and save it to
  // // the appropriate fields:
  // $values = &$form_state['values']['field_lop_topo_num']['und'][0];
  // $input = &$form_state['input']['field_lop_topo_num']['und'][0];
  //
  $legs = substr_count($nickel, 'e');
  // $values['field_lop_leg_number']['und'][0]['value'] = $legs;
  // $input['field_lop_leg_number']['und'][0]['value'] = $legs;
  //
  $propagators = preg_match_all('~[0-9A-Z]~', $nickel);
  // $values['field_lop_prop_num']['und'][0]['value'] = $propagators;
  // $input['field_lop_prop_num']['und'][0]['value'] = $propagators;
  //
  $vertices = substr_count($nickel, '|');
  // $values['field_lop_vertex_number']['und'][0]['value'] = $vertices;
  // $input['field_lop_vertex_number']['und'][0]['value'] = $vertices;
  //
  $loops = $propagators - $vertices + 1;
  // $values['field_lop_loop_number']['und'][0]['value'] = $loops;
  // $input['field_lop_loop_number']['und'][0]['value'] = $loops;


  // Write topological numbers to extra array in $form_state for future
  // use.
  $form_state['topo_nums']['field_lop_leg_number'] = $legs;
  $form_state['topo_nums']['field_lop_prop_num'] = $propagators;
  $form_state['topo_nums']['field_lop_vertex_number'] = $vertices;
  $form_state['topo_nums']['field_lop_loop_number'] = $propagators - $vertices + 1;

  // $prop_num = 13;
  //
  // for ($i = 0; $i < $prop_num; $i++)
  // {
  //   $iplus = $i + 1;
  //   $form_state['values']['field_lop_props']['und'][$i]['field_lop_prop_nr']['und'][0]['value'] = "$iplus";
  //   $form_state['input']['field_lop_props']['und'][$i]['field_lop_prop_nr']['und'][0]['value'] = "$iplus";
  // }

  // We set 'step' to 2 such that when the form gets build next time,
  // it will build the second step
  $form_state['step'] = 2;
  $form_state['rebuild'] = TRUE;
}

/**
 * Submit handler for loopedia_integral_second_step back button.
 */
function nickelplay_integral_back_submit_2(&$form, &$form_state)
{
  $form_state['step'] = 1;
  $form_state['rebuild'] = TRUE;
}




/**
 * Callback function for the second step of the integral sumbission form.
 */
function nickelplay_integral_second_step(&$form, &$form_state)
{
  // Hide some elements
  $elements = array(
    &$form['field_lop_input'],
    // &$form['field_lop_topo_num'],
    &$form['field_lop_internal_stuff'],
    &$form['field_lop_color_num'],
  );
  nickelplay_hide_elements($elements);

  // $num_legs = $form_state['values']['lop_leg_number']['und'][0]['value'];
  // $num_prop = $form_state['values']['lop_propagator_number']['und'][0]['value'];


  // // Display calculated numbers in a fieldset. This way, the user cannot
  // // change them.
  // $topo_values = &$form_state['values']['field_lop_topo_num']['und'][0];
  // $form['display_calc_topo'] = array(
  //   '#type' => 'fieldset',
  //   '#title' => 'Topological numbers for the integral',
  //   '#description' => '
  //   <ul>
  //   <li>Nickel Index: ' .
  //     $topo_values['field_lop_nickel']['und'][0]['value'] . '</li>
  //   <li>Number of legs:  ' .
  //     $topo_values['field_lop_leg_number']['und'][0]['value'] . '</li>
  //   <li>Number of vertices: ' .
  //     $topo_values['field_lop_vertex_number']['und'][0]['value'] . '</li>
  //   <li>Number of loops: ' .
  //     $topo_values['field_lop_loop_number']['und'][0]['value'] . '</li>
  //   <li>Number of propagators: ' .
  //     $topo_values['field_lop_prop_num']['und'][0]['value'] . '</li>
  //   </ul>',
  // );
  // // Store this fieldset in $form_state for next steps
  // $form_state['display_calc_topo'] = $form['display_calc_topo'];

  // Set calculated values of fields and make them read only (#disabled,
  // greyed out)
  $tops = array(
    'field_lop_nickel',
    'field_lop_leg_number',
    'field_lop_prop_num',
    'field_lop_vertex_number',
    'field_lop_loop_number',
  );
  foreach ($tops as $num)
  {
    $form['field_lop_topo_num']['und'][0][$num]['#disabled'] = TRUE;
    $form['field_lop_topo_num']['und'][0][$num]['und'][0]['value']['#value'] = $form_state['topo_nums'][$num];
  }


  // Display generated Feynman Graph
  $form['feynman_graph'] = array(
    '#type' => 'markup',
    '#markup' => '<img src="'.
      $form_state['values']['field_lop_internal_stuff']['und'][0]['field_lop_picture_path']['und'][0]['value'] .
      '" alt="generated_graph">',
    '#weight' => 9,
  );


  // The same Feynman graph again
  $form['feynman_graph_2'] = $form['feynman_graph'];
  $form['feynman_graph_2']['#weight'] = 11;


  // {
  // Adjust the widgets for propagators and legs
  // $prop_num = $topo_values['field_lop_prop_num']['und'][0]['value'];
  $prop_num = $form_state['topo_nums']['field_lop_prop_num'];
  // $leg_num = $topo_values['field_lop_leg_number']['und'][0]['value'];
  $leg_num = $form_state['topo_nums']['field_lop_leg_number'];
  //
  // $form['field_lop_props']['#pre_render'][] = 'nickelplay_field_lop_props_pre_render';
  // Or we just call the function ourselves:
  $form['field_lop_props'] = nickelplay_field_lop_props_pre_render($form['field_lop_props'], $prop_num);

  $form['field_lop_legs_virt'] = nickelplay_field_lop_legs_virt_pre_render($form['field_lop_legs_virt'], $leg_num);
  // }




  // Buttons:

  $form['actions']['back'] = array(
    '#type' => 'submit',
    '#value' => t('<< Back'),
    '#submit' => array('nickelplay_integral_back_submit_2'),
    //
    // We don't want to validate the fields because they will be
    // validated once the user goes forward. #limit_validation_errors()
    // takes an array of elements that will be validated. Everything
    // else will not be validated. See
    // https://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#limit_validation_errors
    //
    // This should be used carefully in multi-step forms. Especially if
    // you have a multi-step form which computes something out of the
    // $form_state['values'][...]. If you use '#limit_validation_errors'
    // on a button to go back one step, there won't be any
    // $form_state['values'][...]. This is why we don't use it in the
    // button from step 3 to step 2.
    '#limit_validation_errors' => array(),
  );

  // $form['actions']['next'] = array(
  //   '#type' => 'submit',
  //   '#value' => 'Next >>',
  //   '#submit' => array('nickelplay_integral_next_submit_2'),
  //   // '#validate' => array('form_example_tutorial_8_next_validate'),
  // );
  // $form['actions']['submit']['#attributes']['class']['hide_me'] = 'element-hidden';

  // dpm($form_state);
}


/**
 * Change form fields for Propagators
 *
 * Callback function to change the rendering of a form element
 *
 * @param array $element
 *   The original form element
 *
 * @return array $element
 *   The altered form element
 */
function nickelplay_field_lop_props_pre_render($element, $prop_num)
{
  // container-inline is used to make the fields being displayed next to
  // each other instead of under. But this makes visible a field that
  // was hidden with "element-hidden"
  $element['#attributes']['class'][] = 'container-inline';

  foreach ($element['und'] as $key => &$value)
  {
    if (is_int($key))
    {
      if ($key < $prop_num)
      {
        // Change titles to display Propagator number
        $keyplus = $key + 1;
        $value['field_lop_prop_mass']['und']['#title'] .= " $keyplus" ;
        $value['field_lop_prop_power']['und'][0]['value']['#title'] .= " $keyplus" ;
        $value['#nodrag'] = TRUE;

        // // Set propagator number field
        // $value['field_lop_prop_nr']['und'][0]['value']['#default_value'] = "$keyplus";

        // Auto-fill Number field and make it not writable by user.
        // {This solution works; using '#value' in combination with
        // '#disabled'. Other solutions can have the disadvantage that
        // the value of the field is lost for future steps.}

        $value['field_lop_prop_nr']['und'][0]['value']['#value'] = $keyplus;
        $value['field_lop_prop_nr']['#disabled'] = TRUE;

        // // Hide Number field
        // $hide = array(&$value['field_lop_prop_nr']);
        // nickelplay_hide_elements($hide);
      }
      else
      {
        // Hide this element
        // $value['#access'] = FALSE;
        unset($element['und'][$key]);
      }
    }
  }

  return $element;
}

/**
 * Change form fields for legs
 *
 * Callback function to change the rendering of a form element
 *
 * @param array $element
 *   The original form element
 *
 * @return array $element
 *   The altered form element
 */
function nickelplay_field_lop_legs_virt_pre_render($element, $leg_num)
{
  // container-inline is used to make the fields being displayed next to
  // each other instead of under. But this makes visible a field that
  // was hidden with "element-hidden"
  $element['#attributes']['class'][] = 'container-inline';

  foreach ($element['und'] as $key => &$value)
  {
    if (is_int($key))
    {
      if ($key < $leg_num)
      {
        // Change titles to display Propagator number
        $keyplus = $key + 1;
        $value['field_lop_ext_legs_virt']['und']['#title'] .= " $keyplus";
        $value['#nodrag'] = TRUE;
        $value['field_lop_ext_legs_no']['und'][0]['value']['#value'] = $keyplus;
        // $value['field_lop_ext_legs_no']['#value'] = "$keyplus";
        $value['field_lop_ext_legs_no']['#disabled'] = TRUE;
      }
      else
      {
        // Hide this element
        // $value['#access'] = FALSE;
        unset($element['und'][$key]);
      }
    }
  }
  return $element;
}



/**
 * Validates input adjalist/nickel
 *
 * This function validates the given input
 * @param string $graph_id
 * and returns an associative array
 * @return associative array $return
 * with following elements:
 * $return['input_type']
 *   = 'nickel'   if $graph_id was a nickel index
 *   = 'adjalist' if $graph_id was an adjacency list
 * $return['error_code']
 *   = 'nickel_forbidden_characters' if nickel contains
 *       forbidden characters
 *   = 'nickel_wrong_convention' if nickel makes no sense
 *   = 'nickel_non_minimal' if nickel is not minimal
 *   = 'nickel_correct' if nickel is correct
 *
 *   = 'adjalist_forbidden_characters' if adjacency list contains
 *         forbidden characters
 *   = 'adjalist_general_problem' if there was a general problem
 *   = 'adjalist_success' if adjalist could be successfully convertet to
 *         a nickel index.
 *
 * $return['nickel_correct'] contains the correct nickel index as string
 *    if it can be obtained at all.
 */
function nickelplay_integral_form_identifier_validation($graph_id)
{
  $return['error_code'] = '';
  $return['input_type'] = '';
  $return['nickel_correct'] = '';

  if (strpos($graph_id, '|') !==  FALSE)
  {
    // $graph_id contains a '|' character. Therefore it is probably a
    // Nickel index.

    $return['input_type'] = 'nickel';

    // Begin of checking of the given nickel index.
    $nickel_value_given = &$graph_id;

    // Check the formal structure of the given index: it shall only
    // contain "e", "0-9" and "|".
    if (preg_match('/^[e0-9A-Z\|]*$/', $nickel_value_given) !== 1)
    {
      $return['error_code'] = 'nickel_forbidden_characters';
      return $return;
    }

    // Check, if given Nickel index is correct(minimal).
    // {

    // When drupal executes a script, it starts in the project path e.g.
    // /var/www/html/drupal_project/ , where the "sites/" folder is.
    $exec1 = "python sites/default/scripts/minimalnickel.py " .
               escapeshellarg($nickel_value_given) .
               " 2>&1";

    // Save output of script. (trim() is needed here because
    // shell_exec() produces one unwanted whitespace at the end of the
    // output string)
    $nickel_value_correct = trim(shell_exec($exec1));

    if ( strlen($nickel_value_given) != strlen($nickel_value_correct) )
    {
      // GraphState outputs a (long) error message if the nickel string
      // argument is wrong according to the convention. So if the output
      // of the script has not the same length as the given nickel
      // string, something went wrong.

      $return['error_code'] = 'nickel_wrong_convention';
      return $return;
    }
    elseif ( $nickel_value_given != $nickel_value_correct )
    {
      // If the given string has the same length as the outupt but is
      // not equal, then the given nickel index is not minimal.
      $return['error_code'] = 'nickel_non_minimal';
      $return['nickel_correct'] = $nickel_value_correct;
      return $return;
    }
    else
    {
      // If none of the cases above apply, the given nickel Index must be
      // correct.
      $return['error_code'] = 'nickel_correct';
      $return['nickel_correct'] = $nickel_value_correct;
      return $return;
    }
    // }
  }
  // End of checking the Nickel index.
  else
  {
    // $graph_id is probably not a Nickel Index.

    $return['input_type'] = 'adjalist';

    // Begin of the check of the given adjacency list

    $adjalist = &$graph_id;
    // Check if the given adjacency list string contains forbidden
    // characters. Allowed ones are ",", "-", "[", "]", "0-9", " "
    // See http://www.rexegg.com/regex-php.html
    if (preg_match('/^[,\[\]0-9\s-]*$/', $adjalist) !== 1)
    {
      $return['error_code'] = 'adjalist_forbidden_characters';
      return $return;
    }

    // Calculate the Nickel index from the given Adjacency List
    $exec0 = "python sites/default/scripts/edgelist_to_nickel.py " .
              escapeshellarg($adjalist) .
              " 2>&1";
    $generated_nickel = trim(shell_exec($exec0));



    // If the script outputs more than one line (nickel index), then
    // there must have been an error. So if the output $generated_nickel
    // contains a newline character ("\n" == PHP_EOL), an error is
    // displayed.
    // http://stackoverflow.com/questions/9437121/how-to-detect-if-a-string-has-a-new-line-break-in-it
    if (strpos($generated_nickel, PHP_EOL) !== FALSE)
    {
      $return['error_code'] = 'adjalist_general_problem';
      return $return;
    }
    else
    {
      // The adjacency list and generated nickel index seem to be all
      // right.
      $return['error_code'] = 'adjalist_success';
      $return['nickel_correct'] = $generated_nickel;
      return $return;
    }
  }
  // End of check of the given adjacency list.
}




// End: Functions for Integral node form
// *************************************




// Use function hook_field_widget_WIDGET_TYPE_form_alter() to display
// parameters to find something to do with drag (ID)
// https://www.drupal.org/node/1488466


/**
 * Alter widget forms for a specific widget provided by another module.
 *
 * Modules can implement hook_field_widget_WIDGET_TYPE_form_alter() to modify a
 * specific widget form, rather than using hook_field_widget_form_alter() and
 * checking the widget type.
 *
 * @param $element
 *   The field widget form element as constructed by hook_field_widget_form().
 * @param $form_state
 *   An associative array containing the current state of the form.
 * @param $context
 *   An associative array containing the following key-value pairs, matching the
 *   arguments received by hook_field_widget_form():
 *   - "form": The form structure where widgets are being attached to. This
 *     might be a full form structure, or a sub-element of a larger form.
 *   - "field": The field structure.
 *   - "instance": The field instance structure.
 *   - "langcode": The language associated with $items.
 *   - "items": Array of default values for this field.
 *   - "delta": The order of this item in the array of subelements (0, 1, 2,
 *     etc).
 *
 * @see hook_field_widget_form()
 * @see hook_field_widget_form_alter()
 */
function nickelplay_field_widget_field_collection_embed_form_alter(&$element, &$form_state, $context)
{
  // Propagators
  if ($element['#bundle'] == 'field_lop_props')
  {
    // $element['field_lop_prop_nr']['#attributes']['class'][] = 'element-hidden';
  }

  // Legs
  if ($element['#bundle'] == 'field_lop_legs_virt')
  {
    // $element['field_lop_ext_legs_no']['#attributes']['class'][] = 'element-hidden';
  }

  // dpm($element, '$element');
  // dpm($context, '$context');
}


// /**
//  * Implements hook_js_alter()
//  *
//  * @param $javascript
//  *   An array of all JavaScript being presented on the page.
//  *
//  * @see drupal_add_js()
//  * @see drupal_get_js()
//  * @see drupal_js_defaults()
//  */
// function nickelplay_js_alter(&$javascript)
// {
//   drupal_set_message('hello');
//   dpm($javascript);
// }



// /**
//  * Implements hook_field_widget_properties_ENTITY_TYPE_alter()
//  */
// function nickelplay_field_widget_properties_node_alter(&$widget, $context)
// {
//   dpm($widget, '$widget');
//   dpm($context, '$context');
// }

/**
* Implements hook_init().
*
* This function can be used for dirty debugging because it is executed
* on all page requests that are not cached.
*/
function nickelplay_init() {
  // drupal_set_message('Hello');
  // dpm($form);
}


// ********************************************
// Begin: Code for NO tabledrag in multi-valued fields

/**
 * Implements hook_theme_registry_alter().
 */
function nickelplay_theme_registry_alter(&$theme_registry)
{
  if (isset($theme_registry['field_multiple_value_form']))
  {
    $theme_registry['field_multiple_value_form']['type'] = 'module';
    $theme_registry['field_multiple_value_form']['theme path'] = drupal_get_path('module', 'nickelplay');
    $theme_registry['field_multiple_value_form']['function'] = 'nickelplay_theme_field_multiple_value_form';
  }
}

/**
 * Theme function override for multiple-value form widgets.
 *
 * @see theme_field_multiple_value_form() in
 *      drupal/modules/field/field.form.inc
 *
 * This function is taken from http://www.commercialprogression.com/post/how-remove-tabledrag-rearranging-multiple-value-field-widgets
 *
 * This function is just a carbon copy of the original one, except that
 * in the beginning, there is an additional check if a "#nodrag"
 * property is set. If not, it executes the unaltered part of the
 * original function. But if #nodrag is set, it executes the same lines
 * with all parts removed concerning the dragging and weight stuff.
 *
 * Should there be updates to the original function, they have to be
 * merged into this override.
 */
function nickelplay_theme_field_multiple_value_form($variables)
{
  $element = $variables['element'];
  $output = '';

  // The first condition is the override.
  if (($element['#cardinality'] > 1 || $element['#cardinality'] == FIELD_CARDINALITY_UNLIMITED) && isset($element[0]['#nodrag'])) {
    $table_id = drupal_html_id($element['#field_name'] . '_values');
    $required = !empty($element['#required']) ? theme('form_required_marker', $variables) : '';

    $header = array(
      array(
        'data' => '<label>' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . "</label>",
        'class' => array('field-label'),
      ),
    );
    $rows = array();

    // Sort items according to weight
    $items = array();
    foreach (element_children($element) as $key) {
      if ($key === 'add_more') {
        $add_more_button = &$element[$key];
      }
      else {
        $items[] = &$element[$key];
      }
    }
    usort($items, '_field_sort_items_value_helper');

    // Add the items as table rows.
    foreach ($items as $key => $item) {
      // We don't want the weight to render.
      unset($item['_weight']);
      $cells = array(
        drupal_render($item),
      );
      $rows[] = array(
        'data' => $cells,
      );
    }

    $output = '<div class="form-item">';
    $output .= theme('table', array(
      'header' => $header,
      'rows' => $rows,
      'attributes' => array(
        'id' => $table_id,
        'class' => array('field-multiple-table'),
      ),
    ));
    $output .= $element['#description'] ? '<div class="description">' . $element['#description'] . '</div>' : '';
    $output .= '<div class="clearfix">' . drupal_render($add_more_button) . '</div>';
    $output .= '</div>';
  }
  elseif ($element['#cardinality'] > 1 || $element['#cardinality'] == FIELD_CARDINALITY_UNLIMITED) {
    $table_id = drupal_html_id($element['#field_name'] . '_values');
    $order_class = $element['#field_name'] . '-delta-order';
    $required = !empty($element['#required']) ? theme('form_required_marker', $variables) : '';

    $header = array(
      array(
        'data' => '<label>' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . "</label>",
        'colspan' => 2,
        'class' => array('field-label'),
      ),
      t('Order'),
    );
    $rows = array();

    // Sort items according to '_weight' (needed when the form comes back after
    // preview or failed validation).
    $items = array();
    foreach (element_children($element) as $key) {
      if ($key === 'add_more') {
        $add_more_button = &$element[$key];
      }
      else {
        $items[] = &$element[$key];
      }
    }
    usort($items, '_field_sort_items_value_helper');

    // Add the items as table rows.
    foreach ($items as $key => $item) {
      $item['_weight']['#attributes']['class'] = array($order_class);
      $delta_element = drupal_render($item['_weight']);
      $cells = array(
        array(
          'data' => '',
          'class' => array('field-multiple-drag'),
        ),
        drupal_render($item),
        array(
          'data' => $delta_element,
          'class' => array('delta-order'),
        ),
      );
      $rows[] = array(
        'data' => $cells,
        'class' => array('draggable'),
      );
    }

    $output = '<div class="form-item">';
    $output .= theme('table', array(
      'header' => $header,
      'rows' => $rows,
      'attributes' => array(
        'id' => $table_id,
        'class' => array('field-multiple-table'),
      ),
    ));
    $output .= $element['#description'] ? '<div class="description">' . $element['#description'] . '</div>' : '';
    $output .= '<div class="clearfix">' . drupal_render($add_more_button) . '</div>';
    $output .= '</div>';

    drupal_add_tabledrag($table_id, 'order', 'sibling', $order_class);
  }
  else {
    foreach (element_children($element) as $key) {
      $output .= drupal_render($element[$key]);
    }
  }

  return $output;
}

// End: Code for NO tabledrag in multi-valued fields
// ********************************************




/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Specifically FORM_ID = field_ui_field_edit_form
 *
 * Change field settings form (Admin UI)
 */
function nickelplay_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id)
{
  // Add more cardinality (1..30) instead of the default 1..10
  $form['field']['cardinality']['#options'] = array(FIELD_CARDINALITY_UNLIMITED => t('Unlimited')) + drupal_map_assoc(range(1, 30));
  // dpm($form)
}
